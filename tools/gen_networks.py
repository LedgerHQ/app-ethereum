#!/usr/bin/env python3

import os
import sys
import re
import argparse
from pathlib import Path


class Network:
    chain_id: int
    name: str
    ticker: str

    def __init__(self, chain_id: int, name: str, ticker: str):
        self.chain_id = chain_id
        self.name = name
        self.ticker = ticker


def get_network_glyph_name(net: Network, small: bool) -> str:
    if small:
        return f"stax_app_chain_{net.chain_id}"
    return f"stax_chain_{net.chain_id}_64px"


def get_header() -> str:
    return f"""\
/*
 * Generated by {sys.argv[0]}
 */

"""


def gen_icons_array_inc(networks: int, small_networks: int, path: str) -> None:
    with open(path + ".h", "w", encoding="utf-8") as out:
        print(get_header() + f"""\
#ifndef NETWORK_ICONS_GENERATED_H_
#define NETWORK_ICONS_GENERATED_H_

#include <stdint.h>
#include "nbgl_types.h"

typedef struct {{
    uint64_t chain_id;
    const nbgl_icon_details_t *icon;
}} network_icon_t;

extern const network_icon_t g_network_icons[{networks}];
extern const network_icon_t g_network_small_icons[{small_networks}];

#endif // NETWORK_ICONS_GENERATED_H_ \
""", file=out)


def gen_network_array_src(networks: list[Network], small: bool, out) -> None:

    if small:
        print(f"const network_icon_t g_network_small_icons[{len(networks)}] = {{", file=out)
    else:
        print(f"const network_icon_t g_network_icons[{len(networks)}] = {{", file=out)

    for net in networks:
        glyph_name = get_network_glyph_name(net, small)
        glyph_file = f"glyphs/{glyph_name}.gif"
        if os.path.isfile(glyph_file):
            if os.path.islink(glyph_file):
                glyph_name = Path(os.path.realpath(glyph_file)).stem
            print(f"    {{.chain_id = {net.chain_id}, .icon = &C_{glyph_name}}}, // {net.name}",
                    file=out)

    print("};", file=out)


def gen_icons_array_src(networks: list[Network], small_networks: list[Network], path: str) -> None:
    with open(path + ".c", "w", encoding="utf-8") as out:
        print(get_header() + f"""\
#include "glyphs.h"
#include "{os.path.basename(path)}.h"
""", file=out)
# const network_icon_t g_network_icons[{len(networks)}] = {{""", file=out)

        gen_network_array_src(networks, False, out)
        gen_network_array_src(small_networks, True, out)

        # for net in networks:
        #     glyph_name = get_network_glyph_name(net, False)
        #     glyph_file = f"glyphs/{glyph_name}.gif"
        #     if os.path.isfile(glyph_file):
        #         if os.path.islink(glyph_file):
        #             glyph_name = Path(os.path.realpath(glyph_file)).stem
        #         print(f"    {{.chain_id = {net.chain_id}, .icon = &C_{glyph_name}}}, // {net.name}",
        #               file=out)

        # print("};", file=out)


def gen_icons_array(networks: list[Network], small_networks: list[Network], path: str) -> None:
    path += "/net_icons.gen"
    gen_icons_array_inc(len(networks), len(small_networks), path)
    gen_icons_array_src(networks, small_networks, path)


def network_icon_exists(net: Network) -> bool:
    return os.path.isfile(f"glyphs/{get_network_glyph_name(net, False)}.gif")


def network_small_icon_exists(net: Network) -> bool:
    return os.path.isfile(f"glyphs/{get_network_glyph_name(net, True)}.gif")


def main(output_dir: str) -> bool:
    networks: list[Network] = []

    # get chain IDs and network names
    expr = r"{\.chain_id = ([0-9]*), \.name = \"(.*)\", \.ticker = \"(.*)\"},"
    with open("src/network.c", encoding="utf-8") as f:
        for line in f.readlines():
            line = line.strip()
            if line.startswith("{") and line.endswith("},"):
                m = re.search(expr,
                              line)
                assert m.lastindex == 3
                networks.append(Network(int(m.group(1)),
                                        m.group(2),
                                        m.group(3)))

    networks.sort(key=lambda x: x.chain_id)

    gen_icons_array(list(filter(network_icon_exists, networks)),
                    list(filter(network_small_icon_exists, networks)),
                    output_dir)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("OUTPUT_DIR")
    args = parser.parse_args()
    assert os.path.isdir(args.OUTPUT_DIR)
    main(args.OUTPUT_DIR)
